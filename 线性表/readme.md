## 线性表

## 1. 什么是线性表

零个或者多个数据元素的有限序列， 简单点就是头尾顺序排队





## 2. 线性表的存储结构



### 2.1  顺序存储

使用连续的内存地址进行存储。

我们只需要知道这块地址的起始位置和偏移量（如数组中的下标）我们就可以取出对应的数据。



### 2.2 顺序存储的插入与删除

其实所有的算法，归根到底，都是为了更好的解决各个场景的读写，也就是i o， 因为计算机就是根据输入，返回输出的工具，抽象一点，也就是我们所有的操作行为都可以看作是对pc的写入。 然后p c对写入进行逻辑运算，而如何减少io就是算法的核心任务了。



* 获取元素 O(1),GetEle 我们只需要知道元素的起始位置和偏移量就可直接获取到指定位置的数据。不用挨个去遍历，一步到位。 
* 插入元素： 如果插入的是最后一个则可以直接一步到位，但是如果是插入第一个，则需要后面的全部向后蠕动一位， 时间复杂度位O(n-1/2) 将系数忽略位O(n)
* 删除元素： 后面的元素同样会向前移动一位。同理时间复杂度是O（n）







## 3. 链式存储结构

顺序存储的数据结构， 读取快，但是新增和删除比较慢，下面我们看看另一种存储方式。

头尾相连组成一条链条， 这样结构的优点是， 插入元素活着删除元素的时候，只需要改动有限的几个元素，即可，也就是把上一个指向他的元素，改成指向顺延一个。

上面存储数据和指针的数据结构我们叫它结点，节点里包含数据信息，和指针信息。



* 头指针： 链表中第一个结点的存储位置叫做头指针
* 最后一个结点如果后面没有数据了，他的指针信息为null
* 头节点：为了方便操作可以在单链表的第一个节点附近设置一个节点，称为头节点（并不是必须有的），这个结点以附加一些其他信息，如链表的长度





### 3.1 头指针和头节点的异同

* 头指针： 头指针是指向第一个结点的指针，如果有头节点，则指向头节点的指针
* 头指针具有标识作用，所以常用头指针冠以链表的名字
* 无论链表是否为空， 头指针均不为空。头指针是链表的必要元素。



* 头结点是为了操作统一和方便而设立的， 放在第一个元素的结点之前， 他的数据一般无意义，也可以存一下链表长度。
* 有了头结点，对第一个元素前的插入和删除，其操作和其他结点状态统一了
* 头结点不是一个链表的必须的元素。



实例

```c
typedef struct Node{
  ElementType data;
  struct Node *next;
}Node;
```





## 4. 单链表的读取

说白了就是从头开始一个一个的通过next 指针去找下一个， 时间复杂度是O(n)



```c
bool GetElem(LinkList L, int i, ElementTyoe *e){
  	int j;
  LinkList p;
  p = L->next;
  j=1;
   while (p && j<i){
     p = p->next;
     ++j;
   }
  if (!p || j>i){
    return false;
  }
  *e = p->data;
  return true;
}
```



解释一下，就是从头开始便利列表，并计数，当j==i 时也就是访问到了我们第i个元素，当前的p就取到了对应的数据。



## 5. 单链表的插入和删除

插入

```c
bool ListInsert(LinkList *L, int i, ElementType e){
  int j;
  LinkList p,s;
  p=*L;
  j=1;
  while(p&&j<i){
    p=p->next;
    ++j;
  }
  if (!p || j>i){
    return false;
  }
  s= (LinkList)malloc(sizeof(Node))
  s->data = e;
  s->next = p->next;
  p->next = s;
  return true;
}

```



删除:

删除第i 个节点， 并利用e 把值返回出来。

```c
bool ListDelete(LinkList *L, int i, EleTyoe *e){
  int i;
  LinkList p,q;
  P=*L;
  j = 1;
  while(p->next && j<i){
    p= p->next;
    ++j;
  }
  if (!(p->next) || j>i){
    return false;
  }
  q = p->next;
  *e = q->next;
  free(q);
  return true;
}
```





## 6. 单链表的整表创建：

* 头插法

* 尾插法

使用两种方法都可以，需要注意的是，如果采用尾插法的话， 那最好把最后一个元素的内存地址维护一份到头节点， 因为这样就不用在去遍历找到最后一个元素。



## 7， 单链表的整表删除

整表删除也就是一个一个的删除，有一点需要注意，那就是删除元素前一定要用临时变量保存一下，否则容易丢失后面的地址那就麻烦了,造成内存泄漏（因为某种原因内存无法释放，造成内存浪费严重的导致程序崩溃）。



```c
bool ClearList(LinkList *L){
  LinkList p,q;
  p = (*L)->next;
  while(p){
    q = p->next;
    free(p);
    p = q;
  }
  (*L)->next = NULL;
  return true;
}
```



